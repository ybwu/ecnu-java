<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>image_processing</title>
  <style>
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style>
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="../../../css/github.css" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-AMS_CHTML-full" type="text/javascript"></script>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<h1 id="project-3.b-图像处理">Project 3.b 图像处理</h1>
<p>在这个 project 中, 你将使用 Java 进行一些简单的图像处理任务: 包括修改图像颜色, 尺寸以及为图像增加滤镜效果等. 你将看到, 一个好的包通过提供恰当的接口 (API) 能够帮助程序员在不了解底层实现的情况下便捷高效的完成工作. 在具体描述作业之前, 我们首先介绍 Java 内置的颜色类 (java.awt.Color), 以及一个由其他开发者提供的图像类 (Picture.java).</p>
<h2 id="颜色">颜色</h2>
<p>Java将颜色抽象成为 Color 类. 如果需要进行与颜色相关的操作, 需要在源文件开头处出加入以下语句:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode java"><code class="sourceCode java"><a class="sourceLine" id="cb1-1" title="1"><span class="kw">import</span><span class="im"> java.awt.Color;</span></a></code></pre></div>
<p>Color 类使用<a href="https://en.wikipedia.org/wiki/RGB_color_model">RGB模型</a>表示颜色. 每种颜色被三个整数确定. 每个整数的取值范围是 0 到 255, 分别表示红, 绿, 蓝三种颜色的强度. 这三种颜色的不同组合可以产生 256^3 种不同的颜色. 下表是一些颜色的 RGB 表示:</p>
<table>
<thead>
<tr class="header">
<th>Color</th>
<th style="text-align: right;">Red</th>
<th style="text-align: right;">Green</th>
<th style="text-align: right;">Blue</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>红</td>
<td style="text-align: right;">255</td>
<td style="text-align: right;">0</td>
<td style="text-align: right;">0</td>
</tr>
<tr class="even">
<td>绿</td>
<td style="text-align: right;">0</td>
<td style="text-align: right;">255</td>
<td style="text-align: right;">0</td>
</tr>
<tr class="odd">
<td>蓝</td>
<td style="text-align: right;">0</td>
<td style="text-align: right;">0</td>
<td style="text-align: right;">255</td>
</tr>
<tr class="even">
<td>黑</td>
<td style="text-align: right;">0</td>
<td style="text-align: right;">0</td>
<td style="text-align: right;">0</td>
</tr>
<tr class="odd">
<td>深灰</td>
<td style="text-align: right;">100</td>
<td style="text-align: right;">100</td>
<td style="text-align: right;">100</td>
</tr>
<tr class="even">
<td>白</td>
<td style="text-align: right;">0</td>
<td style="text-align: right;">0</td>
<td style="text-align: right;">0</td>
</tr>
<tr class="odd">
<td>黄</td>
<td style="text-align: right;">255</td>
<td style="text-align: right;">255</td>
<td style="text-align: right;">0</td>
</tr>
<tr class="even">
<td>品红</td>
<td style="text-align: right;">255</td>
<td style="text-align: right;">0</td>
<td style="text-align: right;">255</td>
</tr>
<tr class="odd">
<td>褐</td>
<td style="text-align: right;">160</td>
<td style="text-align: right;">82</td>
<td style="text-align: right;">45</td>
</tr>
</tbody>
</table>
<p>创建不同的颜色需要通过 Color 类的<strong>构造函数</strong>和<code>new</code>操作符:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode java"><code class="sourceCode java"><a class="sourceLine" id="cb2-1" title="1"><span class="bu">Color</span> red    = <span class="kw">new</span> <span class="bu">Color</span>(<span class="dv">255</span>,   <span class="dv">0</span>,   <span class="dv">0</span>);  </a>
<a class="sourceLine" id="cb2-2" title="2"><span class="bu">Color</span> white  = <span class="kw">new</span> <span class="bu">Color</span>(<span class="dv">255</span>, <span class="dv">255</span>, <span class="dv">255</span>);  </a>
<a class="sourceLine" id="cb2-3" title="3"><span class="bu">Color</span> sienna = <span class="kw">new</span> <span class="bu">Color</span>(<span class="dv">160</span>,  <span class="dv">82</span>,  <span class="dv">45</span>);</a></code></pre></div>
<p>Color 类的提供所有方法 (API) 在 <a href="http://docs.oracle.com/javase/6/docs/api/java/awt/Color.html">Java文档</a> 中可以查询到. 其中我们可能会用到的方法总结如下. 我们建议在开始作业之前, 你可以尝试创建一些颜色, 并对所创建的颜色对象调用这些方法, 输出它们的返回值, 以便帮助你理解这些 API 的作用.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">方法 \</th>
<th style="text-align: left;">说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Color(int r, int g, int b)</td>
<td style="text-align: left;">Color 对象的构造函数</td>
</tr>
<tr class="even">
<td style="text-align: left;">int getRed()</td>
<td style="text-align: left;">获得红色的强度</td>
</tr>
<tr class="odd">
<td style="text-align: left;">int getGreen()</td>
<td style="text-align: left;">获得绿色的强度</td>
</tr>
<tr class="even">
<td style="text-align: left;">int getBlue()</td>
<td style="text-align: left;">获得蓝色的强度</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Color brighter()</td>
<td style="text-align: left;">返回一个更深的颜色</td>
</tr>
<tr class="even">
<td style="text-align: left;">Color darker()</td>
<td style="text-align: left;">返回一个更浅的颜色</td>
</tr>
<tr class="odd">
<td style="text-align: left;">String toString()</td>
<td style="text-align: left;">该颜色的String表示</td>
</tr>
<tr class="even">
<td style="text-align: left;">boolean equals(Color c)</td>
<td style="text-align: left;">是否与颜色c相同</td>
</tr>
</tbody>
</table>
<p>下面我们将以计算颜色的亮度 (Luminance) 为例, 说明如何使用 Color 类. 颜色的亮度表征了显示该颜色时需要使用多少强度的光. 直观上亮度越大, 该颜色越明亮. 严格的定义如下:</p>
<pre><code>亮度 = 0.299*r + 0.587*g + 0.114*b</code></pre>
<p>其中, r, g, b分别代表该颜色的红, 绿, 蓝强度. 以下为对应的 Java 函数:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode java"><code class="sourceCode java"><a class="sourceLine" id="cb4-1" title="1"><span class="kw">import</span><span class="im"> java.awt.Color;</span></a>
<a class="sourceLine" id="cb4-2" title="2"></a>
<a class="sourceLine" id="cb4-3" title="3"><span class="kw">public</span> <span class="kw">class</span> Luminance {</a>
<a class="sourceLine" id="cb4-4" title="4"></a>
<a class="sourceLine" id="cb4-5" title="5">    <span class="co">// return the monochrome luminance of given color</span></a>
<a class="sourceLine" id="cb4-6" title="6">    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">double</span> <span class="fu">lum</span>(<span class="bu">Color</span> color) {</a>
<a class="sourceLine" id="cb4-7" title="7">        <span class="dt">int</span> r = color.<span class="fu">getRed</span>();</a>
<a class="sourceLine" id="cb4-8" title="8">        <span class="dt">int</span> g = color.<span class="fu">getGreen</span>();</a>
<a class="sourceLine" id="cb4-9" title="9">        <span class="dt">int</span> b = color.<span class="fu">getBlue</span>();</a>
<a class="sourceLine" id="cb4-10" title="10">        <span class="kw">return</span> <span class="fl">.299</span>*r + <span class="fl">.587</span>*g + <span class="fl">.114</span>*b;</a>
<a class="sourceLine" id="cb4-11" title="11">    }</a>
<a class="sourceLine" id="cb4-12" title="12"></a>
<a class="sourceLine" id="cb4-13" title="13">    <span class="co">// test </span></a>
<a class="sourceLine" id="cb4-14" title="14">    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">void</span> <span class="fu">main</span>(<span class="bu">String</span>[] args) {</a>
<a class="sourceLine" id="cb4-15" title="15">        <span class="dt">int</span>[] a = <span class="kw">new</span> <span class="dt">int</span>[<span class="dv">3</span>];</a>
<a class="sourceLine" id="cb4-16" title="16">        <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; <span class="dv">3</span>; i++) {</a>
<a class="sourceLine" id="cb4-17" title="17">            a[i] = <span class="bu">Integer</span>.<span class="fu">parseInt</span>(args[i]);</a>
<a class="sourceLine" id="cb4-18" title="18">        }</a>
<a class="sourceLine" id="cb4-19" title="19">        <span class="bu">Color</span> c = <span class="kw">new</span> <span class="bu">Color</span>(a[<span class="dv">0</span>], a[<span class="dv">1</span>], a[<span class="dv">2</span>]);</a>
<a class="sourceLine" id="cb4-20" title="20">        <span class="bu">System</span>.<span class="fu">out</span>.<span class="fu">println</span>(<span class="st">&quot;c = &quot;</span> + c);</a>
<a class="sourceLine" id="cb4-21" title="21">        <span class="bu">System</span>.<span class="fu">out</span>.<span class="fu">println</span>(<span class="st">&quot;lum(c) =  &quot;</span> + <span class="fu">lum</span>(c));</a>
<a class="sourceLine" id="cb4-22" title="22">    }</a>
<a class="sourceLine" id="cb4-23" title="23">}</a></code></pre></div>
<h2 id="数字图像">数字图像</h2>
<p>一幅数字图像 (digital image) 在计算机内部被表示成像素矩阵 (pixel matrix). 每一个像素都有自己的颜色. 类比来说, 每个像素好比拼图玩具中的一块, 它们单个看起来都只是简单的色块, 但不同的块组合在一起就能构成完整的图画.</p>
<p>在本次作业中, 我们将使用一个名为 <a href="../src/image_processing/Picture.java">Picture.java</a> 的包. 它提供了对图像操作的封装. 它的详细的文档在<a href="Picture.html">这里</a>. 我们将会用到的部分方法总结如下:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">方法 \</th>
<th style="text-align: left;">说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Picture(String s)</td>
<td style="text-align: left;">从文件 s 创建一个图像对象</td>
</tr>
<tr class="even">
<td style="text-align: left;">Picture(int w, int h)</td>
<td style="text-align: left;">创建一个宽为 w, 高为 h 的空白图像</td>
</tr>
<tr class="odd">
<td style="text-align: left;">int width()</td>
<td style="text-align: left;">获得图像的宽度</td>
</tr>
<tr class="even">
<td style="text-align: left;">int height()</td>
<td style="text-align: left;">获得图像的高度</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Color get(int i, int j)</td>
<td style="text-align: left;">返回像素 (i, j) 的颜色</td>
</tr>
<tr class="even">
<td style="text-align: left;">void set(int i, int j, Color c)</td>
<td style="text-align: left;">设置像素 (i, j) 的颜色为 c</td>
</tr>
<tr class="odd">
<td style="text-align: left;">void show()</td>
<td style="text-align: left;">将该图像显示在一个窗口中</td>
</tr>
<tr class="even">
<td style="text-align: left;">void save(String s)</td>
<td style="text-align: left;">将该图像保存为文件 s</td>
</tr>
</tbody>
</table>
<h2 id="实验内容">实验内容</h2>
<ol type="1">
<li><p>通过命令行参数给定一个图片文件, 输出它的长和宽. (以下各题中的图片文件, 参数都通过命令行参数形式给出).</p></li>
<li><p>给定一个图片文件, 将其转换成为相应的灰度图 (Grayscale). 当 RGB 颜色模型中红绿蓝三色强度取相同值 v 时, 该颜色为灰色, 其灰度值为 v (0&lt;= v &lt;= 255). 图片的灰度图可以通过如下方法得到: 将图中每个像素点的颜色置为灰色, 且这些灰色的灰度值等于该颜色亮度.</p>
<p><img src="../images/baboon.jpg" /> <img src="../images/baboon-grayscale.jpg" /></p></li>
<li><p>给定一个图片文件, 以及参数 w, h, 将其转换成为宽为 w, 高为 h 的图片.</p>
<p><img src="../images/mandrill200x400.jpg" /> <img src="../images/mandrill200x200.jpg" /></p></li>
<li><p>给定一个图片文件, 以及参数N. 输出 N 张图片, 其中第n张图片为从输入图片和其对应灰度图的一个渐变图.</p></li>
</ol>
<!--
5. 给定一个图片文件, 输出一个它的矩形剪裁, 要求尽量去除图片中的空白边界 (automatic cropping). 
-->
<ol start="5" type="1">
<li><p>给定一个图片文件, 以及参数x, y, E. 输出原始图片的一个正方形裁剪, 其中正方形的中心在 (x, y), 边长是 E. x, y, E 为百分比. 例如 x=10, y=20, E=20, 表示中心位于 原始图片宽的10%, 高20%处. 边长为原始宽度的20%.</p></li>
<li><p>给定一个图片文件, 产生该图片的一个镜像图片(关于 y 轴对称)</p></li>
<li><p>滤镜 (filters) 可以看作对像素矩阵的某种变换. 通过添加滤镜, 我们可以改变图片的视觉效果. 请实现以下滤镜.</p>
<ul>
<li>Linear filter: 每一个像素的颜色变为周围 9 个像素点(包含它本身)颜色的平均值. 这个变换等价于将矩阵[1, 1, 1; 1, 1, 1; 1, 1, 1]/9 与 9个像素点做 <em>卷积 (Convolution)</em> . 而这个矩阵被称为卷积矩阵 (convolutional matrix). 关于卷积矩阵可以参考<a href="https://en.wikipedia.org/wiki/Kernel_(image_processing)">1</a>, <a href="https://docs.gimp.org/2.6/en/plug-in-convmatrix.html">2</a>.</li>
<li>Blur filter: 卷积矩阵为 [1/13, 1/13, 1/13; 1/13, 5/13, 1/13; 1/13, 1/13, 1/13].</li>
<li>Emboss filter: 卷积矩阵为 [-1, 0, 1; -1, 1, 1; -1, 0, 1], 或者 [1, 0, -1; 2, 0, -2; 1, 0, -1] 或者[-1, -1, 0; -1, 1, 1; 0, 1, 1].</li>
<li>Sharpen filter: 卷积矩阵为 [0, -1, 0; -1, 5, -1; 0, -1, 0].</li>
<li>Oil painting filter: 给定参数 w, 将每个像素 (i, j) 的颜色替换为所有与 (i, j) <em>Manhattan 距离</em> 小于 w 的像素点中出现次数最多的颜色. 其中 Manhattan 距离(也称为 <span class="math inline">\(l_1\)</span> 距离)定义见 <a href="https://en.wikipedia.org/wiki/Taxicab_geometry">3</a>, <a href="http://mathworld.wolfram.com/TaxicabMetric.html">4</a>.</li>
</ul></li>
<li><p>提升一张图片的亮度 (Brightness).</p></li>
<li><p>图片的滤镜效果可以看成像素矩阵的一种变换. 相比于使用固定的卷积矩阵, 这些复杂的滤镜可能经过了美工设计师的设计. 但无论怎样, 确定某种滤镜对应的变换, 只需确定每种颜色经过滤镜后被变换成了哪一种颜色. 选择一款手机App(比如Instagram, 足迹, 美图秀秀等) 以及其中的一个内置滤镜, 编写一个java程序来实现这个滤镜.</p></li>
</ol>
<!--
10. 董小姐, 她嘴角向下的时候很美, 像安和桥下清澈的水. 你爱上了这匹野马, 可家里却没有草原. 这让你感到绝望, 程序员. 董小姐熄灭了烟翻起照片, 一张是北方寒夜里的四季如春, 一张是南方艳阳里的大雪纷飞. 你看着照片, 心里一直重复, 这些可能都不会是真的, 董小姐, 事实上, 图片的滤镜效果可以看成像素矩阵的一种变换. 相比于使用固定的卷积矩阵, 这些复杂的滤镜可能经过了美工设计师的设计. 但无论怎样, 确定某种滤镜(比如智能手机 APP (Instagram, 足迹, 美图秀秀等) 提供的内置滤镜)对应的变换, 只需确定每种颜色经过滤镜后被变换成了哪一种颜色. 而你应该能有办法大概的确定这个映射. 好了, 董小姐, 现在那些可能都会是真的了, 写信告诉我今天海是什么颜色吧.
-->
</body>
</html>
